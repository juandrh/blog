{
  
    
  
    
        "post1": {
            "title": "Deep Learning A La Web",
            "content": "Practical Deep Learning for Coders . Motivación . En la lección 2 se ofrecen diferentes opciones para poder usar el modelo entrenando en el curso a través de la web. Recomiendan hacerlo a través de Voila y Binder por ser una forma sencilla de publicar Jupyter notebooks. . Yo, en cambio, he querido ir más allá y crear una aplicación web en la cual se realice la predicción del modelo entrenado en el lado del servidor. Esta aproximación tiene la ventaja de poder implementarse de forma fácil también en apps de dispositivos móviles. . De esta forma, se podrá subir la imagen desde la web al servidor, devolviendo el resultado obtenido. . Preparación del entorno . En el terminal: . Crea un entorno virtual donde trabajar: . | . python3 -m venv env1 source env1/bin/activate | . Si se quiere salir del entorno: .   . deactivate | . Instala Flask: framework que permite crear aplicaciones web rápidamente . | . pip3 install flask python -m flask --version | . Crea directorio donde alojar la web y dos subcarpetas que usará la app . | . mkdir web cd web . mkdir templates . mkdir static . | . Nota: no cambiar el nombre de templates y static ya que los usará Flask . Archivos de la aplicación . Crea un archivo de python con tu editor de textos (yo uso VS Code) en la carpeta “web”. Combinaremos el código de nuestro modelo de Deep Learning usado para el curso y escrito en un Jupyter Notebook y el código específico de Flask que generará la web. . | . import fastbook from fastbook import * from fastai.vision import * from flask import Flask, render_template, request, redirect, url_for, abort, send_from_directory import os from werkzeug.utils import secure_filename import imghdr . fastbook.setup_book() . # Se importa nuestro modelo preentrenado “export.pkl” . path=Path() path.ls(file_exts=’.pkl’) learn_inf=load_learner(path/’export.pkl’) . # valores para uso de Flask app = Flask(__name__) app.config[‘MAX_CONTENT_LENGTH’] = 2 * 1024 * 1024 app.config[‘UPLOAD_EXTENSIONS’] = [‘.jpg’, ‘.png’, ‘.gif’] app.config[‘UPLOAD_PATH’] = ‘static’ . # función que valida la extensión del archivo def validate_image(stream): header = stream.read(512) stream.seek(0) format = imghdr.what(None, header) if not format: return None return ‘.’ + (format if format != ‘jpeg’ else ‘jpg’) . # función que valida el tamaño del archivo @app.errorhandler(413) def too_large(e): return “File is too large”, 413 . # función de genera la página pricipal @app.route(‘/’) def index(): for f in os.listdir(app.config[‘UPLOAD_PATH’]): os.remove(os.path.join(app.config[‘UPLOAD_PATH’], f)) return render_template(‘inicio.html’) . # función generada tras pulsar boton de Clasificación @app.route(‘/’, methods=[‘POST’]) def upload_files(): files = os.listdir(app.config[‘UPLOAD_PATH’]) uploaded_file = request.files[‘file’] filename = secure_filename(uploaded_file.filename) if filename != ‘’: file_ext = os.path.splitext(filename)[1] if file_ext not in app.config[‘UPLOAD_EXTENSIONS’] or file_ext != validate_image(uploaded_file.stream): return “Invalid image”, 400 . filenamefull =os.path.join(app.config[‘UPLOAD_PATH’], filename) uploaded_file.save(filenamefull) #guardar la imagen, se mostrará en el resultado . img = PILImage.create(os.path.join(filenamefull)) pred,pred_inx,prob=learn_inf.predict(img) # uso del modelo para hacer la predicción prediccion=f’Prediccion: {pred}; probabilidad: {prob[pred_inx]:.04f}’ . return render_template(‘resultado.html’,prediccion=prediccion, files=files,imagen=filenamefull) . Dentro de “templates” creamos dos archivo html “inicio.html” y “resultado.html” . | . inicio.html . &lt;!doctype html&gt; &lt;!--Aplicacion web basica: se elige una imagen, se envia al servidor para pasarla por el modelo entrenado--&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Clasificador de lunares&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Clasificador de lunares&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Clasificar&quot;&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; | . resultado.html . &lt;!doctype html&gt; &lt;!--Aplicacion web basica: se muestra la imagen elegida y el resultado de la prediccion--&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Clasificador de lunares&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Clasificador de lunares&lt;/h1&gt; &lt;img src=&quot;&quot; style=&quot;width: 128px&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;br&gt; &lt;button onclick=&quot;goBack()&quot;&gt;Volver&lt;/button&gt; &lt;script&gt; function goBack() { window.history.back(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; | . Publicación de la aplicación . Iniciar el servidor web con Flask en modo local: . | . export FLASK_APP=app . flask run . | . Abrir navegador y colocar en la barra de direcciones: . | .   . http://127.0.0.1:5000/ | . Averiguar la dirección ip en mi red: . | .   . ip a | . . Ejecutar la aplicación de forma visible dentro de mi red: . | .   . flask run –host=0.0.0.0 | . Ahora podrás acceder desde cualquier dispositivo que esté conectado a tu red (a tu WIFI, por ejemplo) . . . Ejecutar flask de forma visible fuera de mi red: . | . Para ello necesitaremos un servidor con acceso a la red que ejecute nuestra aplicación. Podemos montarlo nosotros o usar los servicios de otras empresas como, por ejemplo: . Heroku . | Microsoft Azure . | Amazon AWS . | SeeMe.ai . | .",
            "url": "https://juandrh.github.io/blog/2021/07/16/deep-learning-a-la-web.html",
            "relUrl": "/2021/07/16/deep-learning-a-la-web.html",
            "date": " • Jul 16, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Lección02",
            "content": "Fuente: curso “Practical Deep Learning for Coders” (Fast.ai) . Deep Learning en la práctica . Sirve para resolver multitud de problemas, pero podemos acercarnos con una de estas mentalidades erróneas: . subestimar las limitaciones y sobreestimar la capacidades: lleva a resultados pobres al principio. . | sobreestimar las limitaciones y subestimar las capacidades: laleja del uso de la herramienta. . | subestimar las limitaciones (lleva a errores en la ejecución) y capacidades (no se intentan soluciones que pueden ser beneficiosas) . | . Siempre será mejor trabajar de menos a más, averiguando los límites y capacidades del problema, asumiendo gradualmente los riesgos. . Comienzo del proyecto . Pasos: . Seleccionar el proyecto. . | Ver disponibilidad de datos . | . Consejos: . trabajar de principio a fin en el proyecto, no esperar a tener el proyecto o datos perfectos. Esto ayuda a averiguar cuantos datos necesitamos. . | empezar con un prototipo que luego mejorará hasta que se ponga en producción . | si no encuentras proyecto, usa un proyecto que ya exista, como los que hay en las competiciones de Kaggle. . | si estás empezando no escojas un proyecto demasiado novedoso, si algo falla no tendrás mucha ayuda. . | . Usos actuales . Imagenes: reconocimiento de objetos, segmentación, otros usos diferentes de la imagen . | Texto (procesamiento del lenguaje natural:NLP): clasificar, resumir, generar textos (aunque no generan respuestas correctas), traducir. . | Combinando textos e imágenes (sin garantía de que resultados correctos, se aconseja supervisión humana) . | Datos en tablas y series temporales . | Sistemas recomendadores: aunque tienden a recomendar lo que gusta no lo que puede beneficiar (productos nuevos) . | otros tipos . | . Enfoque del tren motriz . . Define el objetivo que se busca -&gt; averigua qué acciones puedes realizar y qué datos puedes conseguir -&gt; construye el modelo . Datos . En internet hay muchos, es necesario encontrar la forma de descargarlo. . Bing Image Search: . registro en Microsoft Azure . | usar la llave proporcionada (key) para realizar la búsqueda y descarga . | . key = os.environ.get(‘AZURE_SEARCH_KEY’, ‘40757fdc95da4c9990a6e01829dba6e4’) . Nota: cuidado con los datos sesgados, ¿qué obtienes con tus búsquedas? . Aumento de datos: realizar variaciones aleatorias de los datos para que parezcan diferentes: . Rotar, deformación de perspectiva, cambios de brillo y cambios de contraste. . Procesar los datos para el modelo . DataLoaders: almacenan los datos para entrenar y validar . ¿qué tipos de datos tienes? . | ¿cómo tener un listado de los elementos? . | ¿cómo etiquetar los elementos? . | ¿cómo crear un conjunto para validación? . | . Entrenar modelo y limpiar datos . Escoger un modelo para entrenar (Learner) . Obtener la matriz de confusión de las predicciones hechas por el modelo (ClassificationInterpretation) . Usar las herramientas de limpieza de fastai (ImageClassifierCleaner) . Uso del modelo en una aplicación online . Uso del modelo para inferir: . | . exportar el modelo (export) . | cargar el modelo en la aplicacion (load_learner) . | usar modelo para hacer predicciones (predict) . | Crear una Notebook app con el modelo usando IPython widgets (ipywidgets) y Voilà . | . Pasar el Notebook a aplicación real (Voila) . | . Poner el modelo en producción: existen muchas opciones. Usar Binder por su sencillez . | . Uso del modelo en una aplicación móvil . integrar el modelo en la app móvil: . existen muchas opciones pero pueden no soportar toda la funcionalidad de fastai o Pytorch . | será necesario crear una app por tipo de dispositivo (IOS, android,..) . | . | . implementarlo en el servidor: (recomendado) . será necesaria conexión a internet . | los tiempos de latencia pueden incrementarse . | puede que use datos sensibles que no se quieran enviar al servidor . | . | . Precauciones generales . Considerar que el modelo forma parte de un sistema más grande . | Mayor dificultad de comprobar el funcionamiento que en una aplicación estándar: . datos fuera de dominio (no vistos en el entrenamiento) . | cambio de dominio (cambia el entorno) . | . | . Solución para minimizar el riesgo: . . Consecuencias imprevistas, cuidado con los sesgos que retroalimentan el modelo. Considerar el caso en el que el modelo es altamente predictivo y la influencia en el comportamiento. . | .",
            "url": "https://juandrh.github.io/blog/2021/07/15/Lecci%C3%B3n02.html",
            "relUrl": "/2021/07/15/Lecci%C3%B3n02.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Deep Learning Intro",
            "content": "Machine Learning (aprendizaje automático) es la disciplina de programación en la que se obtienen resultados aprendiendo de los datos y no a través de escribir enteramente el código. . El aprendizaje podrá ser: . Supervisado: los datos están etiquetados. . | No supervisado: los datos no están etiquetados. . | . Deep Learning (aprendizaje profundo) forma parte de Machine Learning y se caracteriza por usar redes neuronales artificiales con varias capas. . Un modelo básico de aprendizaje supervisado: . . El objetivo es encontrar un modelo que haga predicciones correctas sobre datos que no haya visto antes. . Etapas: . se tratan los datos para ser procesados . | se escoge una arquitectura . | se dividen los datos en tres grupos: . para entrenamiento . | para validación . | para test . | . | se lanza un proceso de aprendizaje sobre los datos de entrenamiento . | se comprueba el modelo con los datos de validación y se cambian los hiperparámetros si es necesario . | si se consiguen un resultado deseado se guarda el modelo (arquitectura + parámetros) . | .",
            "url": "https://juandrh.github.io/blog/2021/07/10/deep-learning-intro.html",
            "relUrl": "/2021/07/10/deep-learning-intro.html",
            "date": " • Jul 10, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://juandrh.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://juandrh.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}